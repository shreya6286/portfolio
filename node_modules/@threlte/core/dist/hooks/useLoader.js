import { asyncWritable } from '../lib/asyncWritable';
import { useCache } from '../lib/cache';
export const useLoader = (Proto, options = {}) => {
    const { remember, clear: clearCacheItem } = useCache();
    // instantiate the loader
    const loader = new Proto();
    // extend the loader if necessary
    options.extend?.(loader);
    const load = (input, options) => {
        // Allow Async and Sync loaders
        const loadResource = async (url) => {
            if ('loadAsync' in loader) {
                const result = await loader.loadAsync(url, options?.onProgress);
                return options?.transform?.(result) ?? result;
            }
            else {
                return new Promise((resolve, reject) => {
                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);
                });
            }
        };
        if (Array.isArray(input)) {
            // map over the input array and return an array of promises
            const promises = input.map((url) => {
                return remember(() => loadResource(url), [Proto, url]);
            });
            // return an AsyncWritable that resolves to the array of promises
            const store = asyncWritable(Promise.all(promises));
            return store; // TODO: Dirty escape hatch
        }
        else if (typeof input === 'string') {
            // debugger
            const promise = remember(() => loadResource(input), [Proto, input]);
            // return an AsyncWritable that resolves to the promise
            const store = asyncWritable(promise);
            return store; // TODO: Dirty escape hatch
        }
        else {
            // map over the input object and return an array of promises
            const promises = Object.values(input).map((url) => {
                return remember(() => loadResource(url), [Proto, url]);
            });
            // return an AsyncWritable that resolves to the object of promises
            const store = asyncWritable(Promise.all(promises).then((results) => {
                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));
            }));
            return store; // TODO: Dirty escape hatch
        }
    };
    const clear = (input) => {
        if (Array.isArray(input)) {
            input.forEach((url) => {
                clearCacheItem([Proto, url]);
            });
        }
        else if (typeof input === 'string') {
            clearCacheItem([Proto, input]);
        }
        else {
            Object.entries(input).forEach(([key, url]) => {
                clearCacheItem([Proto, key, url]);
            });
        }
    };
    return {
        load,
        clear,
        loader
    };
};
